<!DOCTYPE html><html lang="zh-Hans" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>C++面向对象方法的实现 | 青鸟の小屋</title><meta name="author" content="青鸟"><meta name="copyright" content="青鸟"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="作者 青鸟  面向对象简介 c++是一门面向对象的编程语言，其中最为关键的部分在面向对象的实现，面向对象的实现在于类，可以说类是面向对象的基石。 面向对象是以对象为主体的一种思想，而在计算机中的对象指的就是储存在内存中的一带有特定类型的数据。面向对象 面向对象的核心概念可以概括为：数据封装、继承、多态、泛型编程。  数据封装将一组数据和这组数据有关的操作封装在一起，用户不必知道实现细节，只需要对象">
<meta property="og:type" content="article">
<meta property="og:title" content="C++面向对象方法的实现">
<meta property="og:url" content="http://www.bluebird.com/37182/index.html">
<meta property="og:site_name" content="青鸟の小屋">
<meta property="og:description" content="作者 青鸟  面向对象简介 c++是一门面向对象的编程语言，其中最为关键的部分在面向对象的实现，面向对象的实现在于类，可以说类是面向对象的基石。 面向对象是以对象为主体的一种思想，而在计算机中的对象指的就是储存在内存中的一带有特定类型的数据。面向对象 面向对象的核心概念可以概括为：数据封装、继承、多态、泛型编程。  数据封装将一组数据和这组数据有关的操作封装在一起，用户不必知道实现细节，只需要对象">
<meta property="og:locale">
<meta property="og:image" content="http://www.bluebird.com/img/23.png">
<meta property="article:published_time" content="2022-11-17T12:04:10.000Z">
<meta property="article:modified_time" content="2022-11-20T11:20:13.464Z">
<meta property="article:author" content="青鸟">
<meta property="article:tag" content="c++">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.bluebird.com/img/23.png"><link rel="shortcut icon" href="/img/touxiang.jpg"><link rel="canonical" href="http://www.bluebird.com/37182/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: 'Just',
    min: 'minutes ago',
    hour: 'hours ago',
    day: 'days ago',
    month: 'months ago'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'C++面向对象方法的实现',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-20 19:20:13'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/touxiang.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/goprojecttop.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">青鸟の小屋</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友情链接</span></a></div><div class="menus_item"><a class="site-page" href="/messageboard/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">C++面向对象方法的实现</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">Created</span><time class="post-meta-date-created" datetime="2022-11-17T12:04:10.000Z" title="Created 2022-11-17 20:04:10">2022-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">Updated</span><time class="post-meta-date-updated" datetime="2022-11-20T11:20:13.464Z" title="Updated 2022-11-20 19:20:13">2022-11-20</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/c/">c++</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">Word count:</span><span class="word-count">8.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">Reading time:</span><span>29min</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="C++面向对象方法的实现"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">Post View:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>作者 <a target="_blank" rel="noopener" href="http://www.bluebird.icu/">青鸟</a></p>
<blockquote>
<h2 id="面向对象简介"><a href="#面向对象简介" class="headerlink" title="面向对象简介"></a>面向对象简介</h2></blockquote>
<p><strong>c++<strong>是一门面向对象的编程语言，其中最为关键的部分在面向对象的实现，面向对象的实现在于</strong>类</strong>，可以说<strong>类</strong>是面向对象的基石。</p>
<p>面向对象是以对象为主体的一种思想，而在计算机中的对象指的就是储存在内存中的一带有特定类型的数据。面向对象</p>
<p>面向对象的核心概念可以概括为：<strong>数据封装</strong>、<strong>继承</strong>、<strong>多态</strong>、<strong>泛型编程</strong>。</p>
<ol>
<li><p>数据封装将一组数据和这组数据有关的操作封装在一起，用户不必知道实现细节，只需要对象提供的外部特性接口访问对象。c++中使用类(class)来完成数据封装。</p>
</li>
<li><p>类是继承机制的基石。有了类的层次结构和继承性，不同对象的共同性只需要被定义一次。</p>
</li>
<li><p>所谓多态就是一个接口多种实现。在不同的上下文语境中，使用同一个接口会得到不同的响应。在c++中接口的实现就是函数。多态的概念用在函数上就是函数重载。</p>
</li>
<li><p>很多代码除了数据类型以外，其他都差不多。泛型编程就是以一种独立于任何特定类型的方式来编写代码。实际上是一种特殊的多态，实现的方式是类型的参数化。在c++中。泛型编程主要依靠<strong>模板</strong>来实现</p>
</li>
</ol>
<p>下面分别来重点介绍后面三种性质：</p>
<br/>

<blockquote>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2></blockquote>
<h3 id="继承的概念及声明"><a href="#继承的概念及声明" class="headerlink" title="继承的概念及声明"></a>继承的概念及声明</h3><p>后代的类对于父类特征的全盘接受的行为就是<strong>继承</strong></p>
<p>两个类满足以下的关系：上层分类的全部特性将自动传递给下层分类而无需显示的声明，下层类会逐步增加上层类中没有的特性。</p>
<p>当创建一个类时，我们不需要重新编写新的数据成员和成员函数，只需指定新建的类继承了一个已有的类的成员即可。这个已有的类称为基类，新建的类称为派生类。一个类可以派生自多个类，这意味着，它可以从多个基类继承数据和函数。定义一个派生类，我们使用一个类派生列表来指定基类。类派生列表以一个或多个基类命名，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class derived-class: access-specifier base-class</span><br></pre></td></tr></table></figure>

<p>其中，访问修饰符 access-specifier 是 public、protected 或 private 其中的一个，base-class 是之前定义过的某个类的名称，我们称为<strong>基类</strong>。如果未使用访问修饰符 access-specifier，则默认为 private，而derived-class我们称其为<strong>派生类</strong>。</p>
<p>派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 private。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span> &#123;</span><br><span class="line">    <span class="comment">// eat() 函数</span></span><br><span class="line">    <span class="comment">// sleep() 函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span> : <span class="keyword">public</span> Animal &#123;</span><br><span class="line">    <span class="comment">// bark() 函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以根据访问权限总结出不同的访问类型，如下所示：</p>
<table>
<thead>
<tr>
<th>访问</th>
<th>public</th>
<th>protected</th>
<th>private</th>
</tr>
</thead>
<tbody><tr>
<td>同一个类</td>
<td>yes</td>
<td>yes</td>
<td>yes</td>
</tr>
<tr>
<td>派生类</td>
<td>yes</td>
<td>yes</td>
<td>no</td>
</tr>
<tr>
<td>外部的类</td>
<td>yes</td>
<td>no</td>
<td>no</td>
</tr>
</tbody></table>
<p>一个派生类继承了所有的基类方法，但下列情况除外：</p>
<ol>
<li><p>基类的析构函数。</p>
</li>
<li><p>基类的重载运算符。</p>
</li>
<li><p>基类的友元函数。</p>
</li>
</ol>
<p>假设有一个基类 Shape，Rectangle 是它的派生类，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std; </span><br><span class="line"><span class="comment">// 基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;</span><br><span class="line">      <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="继承类型"><a href="#继承类型" class="headerlink" title="继承类型"></a>继承类型</h3><p>当一个类派生自基类，该基类可以被继承为 public、protected 或 private 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。</p>
<p>我们几乎不使用 protected 或 private 继承，通常使用 public 继承。当使用不同类型的继承时，遵循以下几个规则：</p>
<ol>
<li><p>公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。</p>
</li>
<li><p>保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。</p>
</li>
<li><p>私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。</p>
</li>
</ol>
<h3 id="继承的实现原理"><a href="#继承的实现原理" class="headerlink" title="继承的实现原理"></a>继承的实现原理</h3><p>同聚集和组合一样，继承是两个类合作的另一种方式。</p>
<p>采用继承方式时，派生类对象是在基类对象的基础上扩展而构建。也就是说，派生类对象的前半部分是一个完整的基类对象（称为基类子对象）。这样一来就可以认为基类的所有成员直接成为派生类的成员，除了基类的私有成员外，派生类还可以访问基类的其他所有成员。但其实“基类的所有成员直接成为派生类的成员”这种说法并不准确。准确的说基类子对象的作用域和派生类的作用域还是严格分开的。</p>
<p>上面这种说法之所可以成立，是因为编译器自己的<strong>名字查找机制</strong>的作用。当使用一个派生类成员时，名字查找机制首先在自己的作用域中查找该成员是否存在，如果找到则使用它；否则在它的基类中查找（可能直至继承链的顶端），如果找到则使用它，否则会抛出错误。</p>
<p>由此可知，如果一个成员在派生类和基类的作用域中都存在，名字查找机制确保我们使用的是派生类自己的。</p>
<p>可以看出，名字查找机制确保了继承来的成员像是派生类自己的一样。这使得我们用这些成员时，无需显示地穿越作用域界限。特别值得注意的是，需要关注成员的访问属性，以及继承访问控制带来的影响。</p>
<p>同时名字查找机制让基类的某些数据成员可以在派生类中被重新定义，派生类会覆盖基类中的成员。基类中的成员函数也可以被重新定义。这种重载的原理是类作用域的区别加上名字查找机制的保障。</p>
<h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>如果派生类的构造函数与其基类的功能完全相同，即他们都是初始化只初始化那些二者共同拥有的成员。那么派生类中可以不用显示地定义自己的构造函数，而是使用using声明直接引入基类的构造函数。继承的构造函数会初始化派生类对象中的基类子函数对象。不过这种初始化过程只被看作一次函数调用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> : <span class="keyword">public</span> B</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">using</span> B:B;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里的派生类D继承了B的所有构造函数。甚至包括重载的赋值运算符。</p>
<p>注意：虽然构造函数可以被继承，但是析构函数不行。因为析构函数的作用是释放对象的内存。由于派生类占有的资源极有可能和基类不同，因此基类的析构函数不能被继承。但如果它是虚的，则能被基类覆盖。</p>
<h3 id="基类子对象的初始化"><a href="#基类子对象的初始化" class="headerlink" title="基类子对象的初始化"></a>基类子对象的初始化</h3><p>派生类对象包含了一个完整的基类子对象，从内存重解释的角度来看就是：派生类对象可以被重解释为一个基类对象。基于这个事实，在构造派生类对象之前，必须先构建基类子对象。这可以通过在派生类的构造函数的初始化列表中引起基类构造函数的调用实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> :<span class="keyword">public</span> : A</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">B</span>(<span class="type">int</span> x=<span class="number">1</span>,<span class="type">int</span> y=<span class="number">2</span>,std::string n=<span class="string">&quot;hello&quot;</span>):</span><br><span class="line">         <span class="built_in">A</span>(n),<span class="built_in">width</span>(x),<span class="built_in">height</span>(y) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过上述代码可以看出，在基类构造函数调用时需要向其传递参数。这些参数一般来自于派生类自己的构造函数参数列表</p>
<p>在派生类的构造函数的初始化列表中，只能直接访问其直接基类的构造函数，也只能直接初始化自己的成员。否则会引起一个编译错误。</p>
<h3 id="赋值兼容原则"><a href="#赋值兼容原则" class="headerlink" title="赋值兼容原则"></a>赋值兼容原则</h3><p>派生对象中包含了一个基类子对象，这为基类对象和派生对象的赋值兼容奠定了基础。</p>
<p>下面我们假设A是基类,B是派生类。</p>
<h4 id="派生对象和基类对象的赋值"><a href="#派生对象和基类对象的赋值" class="headerlink" title="派生对象和基类对象的赋值"></a>派生对象和基类对象的赋值</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">A x;</span><br><span class="line">B y;</span><br><span class="line">x=y;</span><br></pre></td></tr></table></figure>
<p>这样的赋值是允许的。这种赋值将派生对象中属于基类的部分赋值给了基类对象，属于派生对象的部分被舍弃了。这种现象称为切片。</p>
<p>相反的<code>y=x</code>是非法的，这样的操作会生成一个不完整的派生类对象，因此是非法的。</p>
<h4 id="引用作用于派生类和基对象"><a href="#引用作用于派生类和基对象" class="headerlink" title="引用作用于派生类和基对象"></a>引用作用于派生类和基对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B y;</span><br><span class="line">A &amp;x=y;</span><br></pre></td></tr></table></figure>
<p>引用x的初始化是合法的，且x成为了y的别名。</p>
<p>派生类对象赋值给基类的引用不会引起派生类对象到基类对象的转换。我们从类型的角度来理解这种引用绑定：派生类对象y表示了一段内存，通过这个名字来观察这段内存，显然这段内存是属于一个派生类对象的。而通过基类引用名x来观察这段y的内存，这段内存就会被重解释：x认为那是一个基类对象占据的内存，而多出来的只属于派生类对象的部分对x来说是完全看不见的。就是说虽然y有了一个别名，但是使用这两个名字会有完全不同的结果。x会得到一个基类对象，而y会得到一个派生类对象。可以认为x是y派生对象中基类子对象的一个别名。</p>
<p>那么<code>B &amp;y=x</code>根据上述的原理就是不合法的，因为派生对象会多出一段不属于基类对象的内存，这种引用赋值就是非法的、不安全的。</p>
<h4 id="指针作用于派生类和基类对象"><a href="#指针作用于派生类和基类对象" class="headerlink" title="指针作用于派生类和基类对象"></a>指针作用于派生类和基类对象</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">B y;</span><br><span class="line">A *x=&amp;y;</span><br></pre></td></tr></table></figure>
<p>与引用状况一致，以上的初始化是合法的。此时，指针x只看到了属于基类子对象的部分，而其他的部分都会被忽略。<br>同样的将基类指针赋值给派生类是非法的</p>
<h3 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h3><p>多继承即一个子类可以有多个父类，它继承了多个父类的特性。</p>
<p>C++ 类可以从多个类继承成员，语法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">class &lt;派生类名&gt;:&lt;继承方式1&gt;&lt;基类名1&gt;,&lt;继承方式2&gt;&lt;基类名2&gt;,…</span><br><span class="line">&#123;</span><br><span class="line">&lt;派生类类体&gt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中，访问修饰符继承方式是 public、protected 或 private 其中的一个，用来修饰每个基类，各个基类之间用逗号分隔.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// 基类 Shape</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setWidth</span><span class="params">(<span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         width = w;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">setHeight</span><span class="params">(<span class="type">int</span> h)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         height = h;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width;</span><br><span class="line">      <span class="type">int</span> height;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 基类 PaintCost</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PaintCost</span> </span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getCost</span><span class="params">(<span class="type">int</span> area)</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         <span class="keyword">return</span> area * <span class="number">70</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape, <span class="keyword">public</span> PaintCost</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">getArea</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Rectangle Rect;</span><br><span class="line">   <span class="type">int</span> area;</span><br><span class="line">   Rect.<span class="built_in">setWidth</span>(<span class="number">5</span>);</span><br><span class="line">   Rect.<span class="built_in">setHeight</span>(<span class="number">7</span>);</span><br><span class="line">   area = Rect.<span class="built_in">getArea</span>();</span><br><span class="line">   <span class="comment">// 输出对象的面积</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total area: &quot;</span> &lt;&lt; Rect.<span class="built_in">getArea</span>() &lt;&lt; endl;</span><br><span class="line">   <span class="comment">// 输出总花费</span></span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Total paint cost: $&quot;</span> &lt;&lt; Rect.<span class="built_in">getCost</span>(area) &lt;&lt; endl;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<br/>

<blockquote>
<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2></blockquote>
<p>多态按字面的意思就是多种形态。就是一种接口，多种实现。更具体一点，就是在不同的语境中调用相同的方法，会得到不同的结果。</p>
<p>当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。</p>
<p>C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。</p>
<p>在C++中，多态分为<strong>静态</strong>和<strong>动态</strong>两种，都是通过<strong>函数重载</strong>来实现的</p>
<h3 id="静态多态"><a href="#静态多态" class="headerlink" title="静态多态"></a>静态多态</h3><p>静态多态也被称为<strong>早期匹配</strong>，其实就是在编译时完成。对于被重载的函数，我们只需要满足每个函数的<strong>特征标</strong>不同即可。所谓的特征标便是函数的参数列表。</p>
<p>如<code>swap(int,int)</code>和<code>swap(double,double)</code>和<code>swap(int,int,int)</code>三个的特征标都是不相同的，函数传入参数的数据类型或者数量不同时，我们便认为函数的特征标不同。注意：函数的特征表与传入参数的名称没有什么关系，只和类型与数量有关。</p>
<h3 id="动态多态"><a href="#动态多态" class="headerlink" title="动态多态"></a>动态多态</h3><p>静态的多态只覆盖了编译阶段的多态状况。在下面的案例中，赋值兼容机制保证了指向派生类的基类指针的正确性，也保证了接口使用的一致性。但也使编译器无法鉴别指针指向的真实对象究竟是属于基类还是派生类。显然这一类问题只有在运行时才能被解决。</p>
<p>在运行时在不同的语境下用统一的接口来识别不同的对象就是<strong>动态多态性</strong>，而C++中的虚函数机制使得动态多样性成为了可能</p>
<p>下面的实例中，基类 Shape 被派生为两个类，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span> </span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Rectangle</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Rectangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Triangle</span>: <span class="keyword">public</span> Shape&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Triangle</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>):<span class="built_in">Shape</span>(a, b) &#123; &#125;</span><br><span class="line">      <span class="function"><span class="type">int</span> <span class="title">area</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123; </span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Triangle class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> (width * height / <span class="number">2</span>); </span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 程序的主函数</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">( )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Shape *shape;</span><br><span class="line">   <span class="function">Rectangle <span class="title">rec</span><span class="params">(<span class="number">10</span>,<span class="number">7</span>)</span></span>;</span><br><span class="line">   <span class="function">Triangle  <span class="title">tri</span><span class="params">(<span class="number">10</span>,<span class="number">5</span>)</span></span>;</span><br><span class="line">   <span class="comment">// 存储矩形的地址</span></span><br><span class="line">   shape = &amp;rec;</span><br><span class="line">   <span class="comment">// 调用矩形的求面积函数 area</span></span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line">   <span class="comment">// 存储三角形的地址</span></span><br><span class="line">   shape = &amp;tri;</span><br><span class="line">   <span class="comment">// 调用三角形的求面积函数 area</span></span><br><span class="line">   shape-&gt;<span class="built_in">area</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent class area :</span><br><span class="line">Parent class area :</span><br></pre></td></tr></table></figure>
<p>导致错误输出的原因是，调用函数 area() 被编译器设置为基类中的版本，这就是所谓的静态多态，或静态链接 - 函数调用在程序执行前就准备好了。有时候这也被称为早绑定，因为 area() 函数在程序编译期间就已经设置好了。</p>
<p>单靠简单的函数重载是不能实现真正的多态。派生类的方法必须<strong>覆盖</strong>而不是简单的<strong>重载</strong>，基类的同原型方法。在C++中覆盖操作是通过<strong>虚函数</strong>机制来实现。通过覆盖操作，虽然编译器仍认为调用的是基类中的成员，但是覆盖行为起到了偷梁换柱的作用，实际调用的是派生类的版本。</p>
<p>现在，让我们对程序稍作修改，在 Shape 类中，area() 的声明前放置关键字 virtual，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span></span></span><br><span class="line"><span class="function">      </span>&#123;</span><br><span class="line">         cout &lt;&lt; <span class="string">&quot;Parent class area :&quot;</span> &lt;&lt;endl;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Rectangle class area :</span><br><span class="line">Triangle class area :</span><br></pre></td></tr></table></figure>

<p>此时，编译器看的是指针的内容，而不是它的类型。因此，由于 tri 和 rec 类的对象的地址存储在 *shape 中，所以会调用各自的 area() 函数。</p>
<p>正如您所看到的，每个子类都有一个函数 area() 的独立实现。这就是多态的一般使用方式。有了多态，您可以有多个不同的类，都带有同一个名称但具有不同实现的函数，函数的参数甚至可以是相同的。</p>
<blockquote>
<h3 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h3></blockquote>
<p>虚函数 是在基类中使用关键字<strong>virtual</strong>声明的函数。关键字virtual明确告诉编译器这个函数是一个虚函数，该类派生类中的同名版本将覆盖这个版本。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。<br>我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为动态链接，或后期绑定。</p>
<p>像这样声明了虚函数的类，或者祖先中包含了虚函数声明的类称为<strong>多态类</strong></p>
<p>被virtual关键字修饰的成员函数具有虚特性。虚特性以及呈现虚特性的函数具有以下特点。</p>
<ol>
<li><p>虚特性必须赋给类的成员函数</p>
</li>
<li><p>虚函数不能是全局函数，也不能是类的静态成员函数</p>
</li>
<li><p>不能将友元说明为虚函数，但虚函数可以是另一个类的友元</p>
</li>
<li><p>虚函数特性可以被继承。如果派生类原型一致地重载了基类中的某个虚函数，那么即使在派生类中没有将这个函数显示说明成虚的，它也会被编译器认为是虚的</p>
</li>
</ol>
<blockquote>
<h3 id="虚函数的实现原理"><a href="#虚函数的实现原理" class="headerlink" title="虚函数的实现原理"></a>虚函数的实现原理</h3></blockquote>
<p>为了实现多态，编译器首先会给每个多态类创建一张虚表，表中记录了这个类的所有的虚函数的入口地址。此外编译器还在每一个多态类的对象中设置了一个虚指针，它指向了该类中的虚表</p>
<p>在调用非多态类的成员函数时，编译器会直接找到该函数的入口地址来完成调用。而在调用多态类的虚函数时，编译器会先获得指向对象内置的虚指针(该指针是派生类自己的，而不是基类对象的)，然后在这个虚指针指向的虚表中查询，以获得指定的虚函数的入口地址来完成正确的调用，从而实现了多态。</p>
<blockquote>
<h3 id="纯虚函数和抽象类"><a href="#纯虚函数和抽象类" class="headerlink" title="纯虚函数和抽象类"></a>纯虚函数和抽象类</h3></blockquote>
<p>您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。</p>
<p>声明纯虚函数的语法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> 基类名</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="keyword">virtual</span> 成员函数名(参数列表)=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们可以把基类中的虚函数 area() 改写如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Shape</span> &#123;</span><br><span class="line">   <span class="keyword">protected</span>:</span><br><span class="line">      <span class="type">int</span> width, height;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">      <span class="built_in">Shape</span>( <span class="type">int</span> a=<span class="number">0</span>, <span class="type">int</span> b=<span class="number">0</span>)</span><br><span class="line">      &#123;</span><br><span class="line">         width = a;</span><br><span class="line">         height = b;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// pure virtual function</span></span><br><span class="line">      <span class="function"><span class="keyword">virtual</span> <span class="type">int</span> <span class="title">area</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>&#x3D; 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。</p>
<p>包含纯虚函数声明的类称为<strong>抽象类</strong>，抽象类支持一般概念的表示，是一种未完成的类型，具有以下特点：</p>
<ol>
<li><p>抽象类只能作用于其他类的基类</p>
</li>
<li><p>在抽象类的派生类中，即使通过继承还有未完全实现的纯虚函数存在，那么该派生类仍然是一个抽象类</p>
</li>
<li><p>不能创建抽象类的对象</p>
</li>
<li><p>可以创建和声明抽象的指针和引用</p>
</li>
<li><p>抽象类不能用作函数的参数类型和返回类型；但抽象类的指针可以</p>
</li>
<li><p>抽象类不能作用显示转换的类型</p>
</li>
<li><p>即使在声明了纯虚函数后，给出了这个函数的实现，这个类依然是抽象类</p>
</li>
</ol>
<p>一般的，我们把所有函数成员都是纯虚函数并且没有数据成员的类称为<strong>接口</strong>。</p>
<br/>

<blockquote>
<h2 id="泛型编程"><a href="#泛型编程" class="headerlink" title="泛型编程"></a>泛型编程</h2></blockquote>
<p>泛型编程指的是不依赖任何的具体类型来编写代码，只需要在实例化代码的时候给出具体的数据类型。由于类型的确定在编译之前便已经确定。因此，泛型编程实际上是一种静态的多态。我们将类型参数化，就可以完全兼顾类型检查和减少代码量。</p>
<p>在c++中我们具体的实现依靠<strong>模板</strong>，使用模板机制进行的程序设计就是泛型编程。</p>
<p>C++中的模板有三类：变量模板、函数模板和类模板。下面分开来介绍。</p>
<h3 id="变量模板"><a href="#变量模板" class="headerlink" title="变量模板"></a>变量模板</h3><h4 id="定义和使用类模板"><a href="#定义和使用类模板" class="headerlink" title="定义和使用类模板"></a>定义和使用类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T 变量名 = 初始化表达式；</span><br></pre></td></tr></table></figure>
<p>其中的初始化不是必须的</p>
<p>下面给出一个具体的案例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T var;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">const</span> T pi=<span class="built_in">static_cast</span>&lt;T&gt;(<span class="number">3.1415926536</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">   std::cout&lt;&lt;<span class="number">1.2</span>*<span class="number">1.2</span>*pi&lt;<span class="type">double</span>&gt;&lt;&lt;std::endl;</span><br><span class="line">   std::cout&lt;&lt;<span class="number">2</span>*<span class="number">2</span>*pi&lt;<span class="type">int</span>&gt;&lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">   var&lt;<span class="type">int</span>&gt;=<span class="number">9</span>;</span><br><span class="line">   var&lt;std::string&gt;=<span class="string">&quot;variable template&quot;</span>;</span><br><span class="line">   std::cout&lt;&lt;var&lt;<span class="type">int</span>&gt;<span class="string">&#x27;,&#x27;</span>&lt;&lt;var&lt;std::string&gt; &lt;&lt;std::endl;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出的结果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">4.52389</span></span><br><span class="line"><span class="number">12</span></span><br><span class="line"><span class="number">9</span>,variable <span class="keyword">template</span></span><br></pre></td></tr></table></figure>
<p>变量模板只有在被实例化的时候才会真正地产生代码。在上述代码中，类似于<code>pi&lt;int&gt;</code>这样的语法就是变量模板的实例化形式。我们不妨称实例化的变量变量模板为模板变量</p>
<h4 id="变量模板的特化"><a href="#变量模板的特化" class="headerlink" title="变量模板的特化"></a>变量模板的特化</h4><p>在前面的例子中，对数值模板pi做了模板化，但这个模板不能处理pi是一个字符串的情况<br>。在这个情况下，我们要针对这个需求指定一个pi的特别版本。这种特别的版本称为<strong>特化</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> cstring =<span class="type">const</span> <span class="type">char</span> *;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line">cstring pi&lt;cstring&gt;=<span class="string">&quot;3.1415926536&quot;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="函数模板"><a href="#函数模板" class="headerlink" title="函数模板"></a>函数模板</h3><h4 id="函数模板的定义"><a href="#函数模板的定义" class="headerlink" title="函数模板的定义"></a>函数模板的定义</h4><p>函数模板使用泛型来定义函数，将类型作为参数传递给模板，函数模板特性本质上也是一种参数化过程，相当于是类型参数化来表示。</p>
<p>定义函数的形式化表示如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Anytype1,<span class="keyword">typename</span> Anytype1,...,类型 常量表达式&gt;</span><br><span class="line">返回值类型 函数名(参数列表)&#123;</span><br><span class="line">   函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上述的形式化表达中可以看出，函数模板除了类型参数以外，还可以有其他类型的常量参数，这些参数又被称作为<strong>非类型参数</strong>。非类型参数只能是整数类型(包括所有的整型、字符型、bool型)和枚举类型其中之一。</p>
<p>函数模板并不是一个真正的函数,只是告诉编译器该如何去定义。要让模板工作，我们必须将其实例化，对于实例化的函数，我们称为实例函数或者模板函数。关键字template和typename是必须的，类型名可以任选。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typrname Anytype&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Anytype&amp; &amp;a,Anytype&amp; &amp;b)</span></span>&#123;</span><br><span class="line">    Anytype temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">1</span>&#125;,b&#123;<span class="number">2</span>&#125;;</span><br><span class="line"><span class="built_in">swap</span>(a,b);</span><br></pre></td></tr></table></figure>
<p>我们可以这么理解<code>swap()</code>的实例化过程：编译器将根据上述给定的参数类型生成下面的模板函数,并在调用点选择与给定参数类型完全匹配的版本，从而实现函数的功能。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(<span class="type">int</span> x,<span class="type">int</span> y)&#123;</span><br><span class="line">   <span class="type">int</span> temp;</span><br><span class="line">    temp=x;</span><br><span class="line">    x=y;</span><br><span class="line">    y=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们也可以直接实例化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">swap</span>&lt;<span class="type">int</span>&gt;(a,b);</span><br></pre></td></tr></table></figure>
<p>除了给出类型参数以外，模板还可以给出非类型参数。在这种情况下，函数模板的实例化参数必须显式的给出，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typrname Anytype,Anytype t&gt;</span></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">judge</span><span class="params">(Anytype a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a&lt;t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a&#123;<span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">judge</span>&lt;<span class="type">int</span>,<span class="number">1000</span>&gt;(a);</span><br></pre></td></tr></table></figure>
<p>函数模板的所有参数都可以预先取默认值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;typrname Anytype=<span class="type">int</span>,Anytype t=<span class="number">10</span>&gt;</span><br></pre></td></tr></table></figure>

<h4 id="函数模板的重载"><a href="#函数模板的重载" class="headerlink" title="函数模板的重载"></a>函数模板的重载</h4><p>函数模板允许像重载常规函数一样重载模板定义。并且和常规重载一样，被重载的模板的函数特征标必须不同。注意：并非所有的模板参数必须都是模板参数类型，可以有int之类的常规的数据类型。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typrname Anytype&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Anytype&amp; &amp;a,Anytype&amp; &amp;b)</span></span>&#123;</span><br><span class="line">    Anytype temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Anytype&amp; &amp;a,Anytype&amp; &amp;b,<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        Anytype temp;</span><br><span class="line">        temp=a;</span><br><span class="line">        a=b;</span><br><span class="line">        b=temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>c++编译器在尝试调用函数模板还是同名的非模板函数时遵循下述规则：</p>
<ol>
<li><p>寻找一个参数完全匹配的非模板函数，如果找到了，就调用它</p>
</li>
<li><p>否则，寻找一个函数模板，将其实例化并产生一个匹配的模板函数，如果找到了就调用它</p>
</li>
<li><p>否则，试一下低级的重载，如通过类型转换可产生匹配的函数</p>
</li>
<li><p>如果均为找到，抛出一个报错</p>
</li>
<li><p>如果（1）步骤中有多于一个的选择，抛出一个报错</p>
</li>
</ol>
<p>以上是重载的规则</p>
<h4 id="函数模板的显示具体化"><a href="#函数模板的显示具体化" class="headerlink" title="函数模板的显示具体化"></a>函数模板的显示具体化</h4><p>有一些类型可能是我们自定义的结构体或者类，这个时候就不能直接使用模板，需要显示具体化（特化）。</p>
<p>显示具体化：提供一个具体的函数定义</p>
<p>需要注意的是：具体化化的时候，特化函数模板的参数必须和普通的函数模板的参数一致</p>
<p>当编译器找到函数，调用匹配的具体化模板后，使用该定义，不再使用模板。、</p>
<p>如果在具体化的时候，只用到了模板参数的部分，那么就把这种特化称为函数模板的部分特化，又称作偏特化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;typrname Anytype&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(Anytype&amp; &amp;a,Anytype&amp; &amp;b)</span></span>&#123;</span><br><span class="line">    Anytype temp;</span><br><span class="line">    temp=a;</span><br><span class="line">    a=b;</span><br><span class="line">    b=temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="type">void</span> <span class="built_in">swap</span>&lt;MYstruct&gt;(MYstruct&amp;,MYstruct&amp;);<span class="comment">//完全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;<span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(<span class="type">int</span>,<span class="type">char</span>)</span></span>&#123;&#125;;<span class="comment">//完全特化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;<span class="built_in">void</span> (T,<span class="type">int</span>)&#123;&#125;;<span class="comment">//偏特化</span></span><br></pre></td></tr></table></figure>

<h4 id="显示具体化和显示实例化"><a href="#显示具体化和显示实例化" class="headerlink" title="显示具体化和显示实例化"></a>显示具体化和显示实例化</h4><p>显示示例化意味着直接命令编译器创建特定的实例，<code>swap&lt;int&gt;()</code>或者<br><code>template void swap&lt;int&gt;(int&amp;,int&amp;);</code>,该声明为swap生成int类型实例。</p>
<p>显示具体化是不使用函数模板来生成定义，专门为特定的类型显示化定义函数。这些原型函数必须有自己的定义<code>template&lt;&gt;void swap&lt;MYstruct&gt;(MYstruct&amp;,MYstruct&amp;);</code></p>
<p>我们使用<strong>template</strong>和**template&lt;&gt;**来区分显示示例化和显示具体化</p>
<h3 id="完美转发机制"><a href="#完美转发机制" class="headerlink" title="完美转发机制"></a>完美转发机制</h3><p>完美转发指的是函数模板可以将自己的参数“完美”地转发给内部调用的其它函数。所谓完美，即不仅能准确地转发参数的值，还能保证被转发参数的左、右值属性不变。</p>
<p>在 C++ 中，一个表达式不是左值就是右值。关于左右值的判断，可位于赋值号（&#x3D;）左侧的表达式就是左值；反之，只能位于赋值号右侧的表达式就是右值。有名称的、可以获取到存储地址的表达式即为左值；反之则是右值。</p>
<blockquote>
<p>值得一提的是，左值的英文简写为“lvalue”，右值的英文简写为“rvalue”。很多人认为它们分别是”left value”、”right value” 的缩写，其实不然。lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数据，而 rvalue 译为 “read value”，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据）。</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上所示，function() 函数模板中调用了 otherdef() 函数。在此基础上，完美转发指的是：如果 function() 函数接收到的参数 t 为左值，那么该函数传递给 otherdef() 的参数 t 也是左值；反之如果 function() 函数接收到的参数 t 为右值，那么传递给 otherdef() 函数的参数 t 也必须为右值。</p>
<p>显然，function() 函数模板并没有实现完美转发。一方面，参数 t 为非引用类型，这意味着在调用 function() 函数时，实参将值传递给形参的过程就需要额外进行一次拷贝操作；另一方面，无论调用 function() 函数模板时传递给参数 t 的是左值还是右值，对于函数内部的参数 t 来说，它有自己的名称，也可以获取它的存储地址，因此它永远都是左值，也就是说，传递给 otherdef() 函数的参数 t 永远都是左值。总之，无论从那个角度看，function() 函数的定义都不“完美”。</p>
<p>在c++11之前，通过函数重载来实现完美转发，将一个传入参数类型声明为const T&amp; 即可接受右值变量。</p>
<p>显然，使用重载的模板函数实现完美转发也是有弊端的，此实现方式仅适用于模板函数仅有少量参数的情况，否则就需要编写大量的重载函数模板，造成代码的冗余。为了方便用户更快速地实现完美转发，C++ 11 标准中允许在函数模板中使用右值引用来实现完美转发。</p>
<p>C++11 标准中规定，通常情况下右值引用形式的参数只能接收右值，不能接收左值。但对于函数模板中使用右值引用语法定义的参数来说，它不再遵守这一规定，既可以接收右值，也可以接收左值（此时的右值引用又被称为“万能引用”）。</p>
<p>仍以 function() 函数为例，在 C++11 标准中实现完美转发，只需要编写如下一个模板函数即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此模板函数的参数 t 既可以接收左值，也可以接收右值。但仅仅使用右值引用作为函数模板的参数是远远不够的，还有一个问题继续解决，即如果调用 function() 函数时为其传递一个左值引用或者右值引用的实参，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n = <span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> &amp; num = n;</span><br><span class="line"><span class="built_in">function</span>(num); <span class="comment">// T 为 int&amp;</span></span><br><span class="line"><span class="type">int</span> &amp;&amp; num2 = <span class="number">11</span>;</span><br><span class="line"><span class="built_in">function</span>(num2); <span class="comment">// T 为 int &amp;&amp;</span></span><br></pre></td></tr></table></figure>
<p>其中，由 function(num) 实例化的函数底层就变成了 function(int &amp; &amp; t)，同样由 function(num2) 实例化的函数底层则变成了 function(int &amp;&amp; &amp;&amp; t)。要知道，C++98&#x2F;03 标准是不支持这种用法的，而 C++ 11标准为了更好地实现完美转发，特意为其指定了新的类型匹配规则，又称为引用折叠规则（假设用 A 表示实际传递参数的类型）：<br>当实参为左值或者左值引用（A&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;（A&amp; &amp;&amp; &#x3D; A&amp;）；<br>当实参为右值或者右值引用（A&amp;&amp;）时，函数模板中 T&amp;&amp; 将转变为 A&amp;&amp;（A&amp;&amp; &amp;&amp; &#x3D; A&amp;&amp;）。</p>
<p>读者只需要知道，在实现完美转发时，只要函数模板的参数类型为 T&amp;&amp;，则 C++ 可以自行准确地判定出实际传入的实参是左值还是右值。</p>
<p>通过将函数模板的形参类型设置为 T&amp;&amp;，我们可以很好地解决接收左、右值的问题。但除此之外，还需要解决一个问题，即无论传入的形参是左值还是右值，对于函数模板内部来说，形参既有名称又能寻址，因此它都是左值。那么如何才能将函数模板接收到的形参连同其左、右值属性，一起传递给被调用的函数呢？</p>
<p>C++11 标准的开发者已经帮我们想好的解决方案，该新标准还引入了一个模板函数 forword<T>()，我们只需要调用该函数，就可以很方便地解决此问题。仍以 function 模板函数为例，如下演示了该函数模板的用法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">//重载被调用函数，查看完美转发的效果</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;lvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">otherdef</span><span class="params">(<span class="type">const</span> <span class="type">int</span> &amp; t)</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;rvalue\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//实现完美转发的函数模板</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">function</span><span class="params">(T&amp;&amp; t)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">otherdef</span>(forward&lt;T&gt;(t));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">function</span>(<span class="number">5</span>);</span><br><span class="line">    <span class="type">int</span>  x = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">function</span>(x);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从结果中可以看出普通的转发会使参数类型发生变化，而完美转发不会有任何问题</p>
<h3 id="类模板"><a href="#类模板" class="headerlink" title="类模板"></a>类模板</h3><h4 id="定义和使用类模板-1"><a href="#定义和使用类模板-1" class="headerlink" title="定义和使用类模板"></a>定义和使用类模板</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Anytype1,<span class="keyword">typename</span> Anytype1,...,类型 常量表达式&gt;</span><br><span class="line"><span class="keyword">class</span> 类名&#123;</span><br><span class="line">   <span class="comment">//成员定义</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">类名&lt;具体类型&gt;名称;<span class="comment">//具体实例化一个变量</span></span><br></pre></td></tr></table></figure>
<p>与函数模板相同，类模板的非类型参数必须是整数类型的</p>
<p>除了数据成员外，类模板可以包含如下的成员</p>
<ol>
<li><p>成员函数。类模板的所有成员函数都是模板函数，其动态类型一般都依赖于所属模板的类型参数</p>
</li>
<li><p>成员类。类模板中可能会嵌入一些内部类（不是类对象）的定义。如果这些内部类使用了包围类的类型参数，那么这些类也是类模板。</p>
</li>
<li><p>成员模板。如果一个在类模板内部的类或者成员函数被冠以template关键字，并且它的类型参数不依赖于包围模板，那么它将称为类模板中的模板，即成员模板。</p>
</li>
</ol>
<p>与函数模板不同，类的实例化必须是显示的，例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">list&lt;<span class="type">int</span>&gt;l1&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">list&lt;std::string&gt;&#123;<span class="string">&quot;1&quot;</span>,<span class="string">&quot;2&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>模板类可以接受非类型参数，我们可以使用这些参数为模板来定制一些特性，例如</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> <span class="type">value_t</span>,<span class="type">size_t</span> maxlen&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">array</span>&#123;<span class="keyword">private</span>: <span class="type">value_t</span> arr[maxlen];&#125;;</span><br></pre></td></tr></table></figure>
<p>同时，类模板的各类参数都可以是默认的。与函数的默认参数相同，类的默认参数只能放在参数列表的最右边。</p>
<br/>

<br/>

<p>参考资料：c++程序设计现代方法(白忠建)、c++ primer plus、<a target="_blank" rel="noopener" href="https://www.runoob.com/cplusplus/cpp-tutorial.html">菜鸟教程</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a target="_blank" rel="noopener" href="http://www.bluebird.icu/">青鸟</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="http://www.bluebird.com/37182/">http://www.bluebird.com/37182/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/c/">c++</a></div><div class="post_share"><div class="social-share" data-image="/img/23.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/22536/"><img class="prev-cover" src="/img/25.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">Previous Post</div><div class="prev_info">矩阵+快速幂算法</div></div></a></div><div class="next-post pull-right"><a href="/7153/"><img class="next-cover" src="/img/24.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">Next Post</div><div class="next_info">Vim编辑器</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>Related Articles</span></div><div class="relatedPosts-list"><div><a href="/64316/" title="c++中的复杂指针分析"><img class="cover" src="/img/9.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-28</div><div class="title">c++中的复杂指针分析</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/touxiang.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">青鸟</div><div class="author-info__description"></div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">Articles</div><div class="length-num">15</div></a><a href="/tags/"><div class="headline">Tags</div><div class="length-num">6</div></a><a href="/categories/"><div class="headline">Categories</div><div class="length-num">6</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="mailto:crk2778355976@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>Announcement</span></div><div class="announcement_content">这是青鸟的Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>Catalog</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">面向对象简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF"><span class="toc-number">2.</span> <span class="toc-text">继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E6%A6%82%E5%BF%B5%E5%8F%8A%E5%A3%B0%E6%98%8E"><span class="toc-number">2.1.</span> <span class="toc-text">继承的概念及声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%B1%BB%E5%9E%8B"><span class="toc-number">2.2.</span> <span class="toc-text">继承类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">2.3.</span> <span class="toc-text">继承的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E7%9A%84%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.</span> <span class="toc-text">构造函数的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB%E5%AD%90%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">2.5.</span> <span class="toc-text">基类子对象的初始化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B5%8B%E5%80%BC%E5%85%BC%E5%AE%B9%E5%8E%9F%E5%88%99"><span class="toc-number">2.6.</span> <span class="toc-text">赋值兼容原则</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B4%BE%E7%94%9F%E5%AF%B9%E8%B1%A1%E5%92%8C%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%B5%8B%E5%80%BC"><span class="toc-number">2.6.1.</span> <span class="toc-text">派生对象和基类对象的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.2.</span> <span class="toc-text">引用作用于派生类和基对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BD%9C%E7%94%A8%E4%BA%8E%E6%B4%BE%E7%94%9F%E7%B1%BB%E5%92%8C%E5%9F%BA%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.6.3.</span> <span class="toc-text">指针作用于派生类和基类对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.7.</span> <span class="toc-text">多继承</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%80%81"><span class="toc-number">3.</span> <span class="toc-text">多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">3.1.</span> <span class="toc-text">静态多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%A4%9A%E6%80%81"><span class="toc-number">3.2.</span> <span class="toc-text">动态多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">虚函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">3.4.</span> <span class="toc-text">虚函数的实现原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">3.5.</span> <span class="toc-text">纯虚函数和抽象类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B"><span class="toc-number">4.</span> <span class="toc-text">泛型编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.1.</span> <span class="toc-text">变量模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.1.1.</span> <span class="toc-text">定义和使用类模板</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E6%A8%A1%E6%9D%BF%E7%9A%84%E7%89%B9%E5%8C%96"><span class="toc-number">4.1.2.</span> <span class="toc-text">变量模板的特化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.2.</span> <span class="toc-text">函数模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">4.2.1.</span> <span class="toc-text">函数模板的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">4.2.2.</span> <span class="toc-text">函数模板的重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%98%BE%E7%A4%BA%E5%85%B7%E4%BD%93%E5%8C%96"><span class="toc-number">4.2.3.</span> <span class="toc-text">函数模板的显示具体化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%85%B7%E4%BD%93%E5%8C%96%E5%92%8C%E6%98%BE%E7%A4%BA%E5%AE%9E%E4%BE%8B%E5%8C%96"><span class="toc-number">4.2.4.</span> <span class="toc-text">显示具体化和显示实例化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E7%BE%8E%E8%BD%AC%E5%8F%91%E6%9C%BA%E5%88%B6"><span class="toc-number">4.3.</span> <span class="toc-text">完美转发机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E6%A8%A1%E6%9D%BF"><span class="toc-number">4.4.</span> <span class="toc-text">类模板</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E5%92%8C%E4%BD%BF%E7%94%A8%E7%B1%BB%E6%A8%A1%E6%9D%BF-1"><span class="toc-number">4.4.1.</span> <span class="toc-text">定义和使用类模板</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>Recent Post</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/20721/" title="在SNI审查下的方法"><img src="/img/35.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在SNI审查下的方法"/></a><div class="content"><a class="title" href="/20721/" title="在SNI审查下的方法">在SNI审查下的方法</a><time datetime="2022-12-17T02:40:04.000Z" title="Created 2022-12-17 10:40:04">2022-12-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/61435/" title="在浏览器中输入URL后会发生什么呢？"><img src="/img/28.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="在浏览器中输入URL后会发生什么呢？"/></a><div class="content"><a class="title" href="/61435/" title="在浏览器中输入URL后会发生什么呢？">在浏览器中输入URL后会发生什么呢？</a><time datetime="2022-12-16T13:11:31.000Z" title="Created 2022-12-16 21:11:31">2022-12-16</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/goprojecttop.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By 青鸟</div><div class="framework-info"><span>Framework </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>Theme </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="Read Mode"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="Toggle Between Light And Dark Mode"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="Toggle between single-column and double-column"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="Setting"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="Table Of Contents"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="Back To Top"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>